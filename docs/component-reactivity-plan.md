# 组件内直接使用响应式的迭代计划

## 背景

目前函数组件在 `mountComponent` 内部只执行一次，后续依靠手写 `effect` 才能追踪响应式状态。若要让组件体内直接读取 `reactive` 数据并自动更新 UI，需要为组件引入受控的响应式渲染流程和最小化的更新机制。

## 总体目标

- 组件函数可以直接访问 `reactive`/`ref` 数据，依赖变化时自动触发组件重新渲染。
- 渲染副作用在 `unmount` 时能彻底清理，避免内存泄漏或重复订阅。
- 确保现有测试通过，并补充必要的新用例覆盖组件级响应式行为。

## 迭代路线

1. **渲染副作用基础设施（已完成）**
   - 为组件实例创建 `ReactiveEffect`，封装 `component(props)` 的执行。
   - 在 `mountComponent` 中保存实例状态（最近一次子树、挂载容器、cleanup 钩子）。
   - 支持通过 `effect` 的 `scheduler` 钩子将重新渲染请求放入任务队列（初期可直接同步执行）。

2. **重新渲染流程（粗暴刷新版）（已完成）**
   - 当组件 effect 被触发时，先卸载上次渲染结果，再重新 `mountChild`。
   - 暂时接受全量重建 DOM，确保功能正确性优先。

3. **销毁与清理（已完成）**
   - 扩展 `mountComponent` 创建的实例，暴露 `unmount` 能力。
   - `render`/`createApp` 在卸载或替换节点时，主动调用组件实例的清理逻辑，停止 effect 并断开 DOM 引用。

4. **组件本地状态托管（已完成）**
   - 新增 `component-instance` 模块，统一记录实例的 `setupState`/`ctx` 并暴露 `setCurrentInstance`/`getCurrentInstance` 私有 API，为后续生命周期与组合式扩展打地基。
   - JSX 类型系统强制 `ComponentType` 返回渲染闭包；运行时在 setup 阶段仅执行一次组件函数并校验结果，若未返回闭包会抛出“组件必须返回渲染函数以托管本地状态”。
   - `ReactiveEffect` 现在只负责驱动渲染闭包，组件内部声明的 `reactive`/`ref` 会在 setup 内初始化一次并在每次 rerender 时复用。
   - Demo 与 `runtime-dom` 组件响应式测试已改写为在组件内创建本地 state，并断言卸载后 effect 停止，覆盖 setup 托管的完整路径。

5. **测试补充（已完成）**
   - 在 `test/runtime-dom` 增加用例：组件仅依赖响应式数据且无手写 `effect`，多次 state 更新应正确渲染。
   - 验证卸载后响应式依赖已释放。

6. **（可选）细粒度优化**
   - 将“卸载-重建”替换为最小化的 `patch` 流程，减少 DOM 抖动。
   - 引入简单的更新调度（批量、微任务刷新）。

## 后续考虑

- 为不符合契约的第三方组件提供兼容层，例如 Dev 模式下自动将节点结果包裹成闭包并输出 warning，以降低迁移存量代码的门槛。
- 借助 `currentInstance` 扩展基础生命周期/组合式 API（如 `onMounted`、实例级依赖注入），并让 `setupState` 真正被这些 API 读取与注册，打通完整的组合式体验。

## 阶段验收标准

- 第 2 步完成后：组件无需额外 `effect` 即可随响应式状态更新。
- 第 3 步完成后：重复挂载/卸载无内存或副作用残留。
- 第 5 步（可选）：在性能敏感场景下减少不必要的 DOM 重建。
