# 组件内直接使用响应式的迭代计划

## 背景

目前函数组件在 `mountComponent` 内部只执行一次，后续依靠手写 `effect` 才能追踪响应式状态。若要让组件体内直接读取 `reactive` 数据并自动更新 UI，需要为组件引入受控的响应式渲染流程和最小化的更新机制。

## 总体目标

- 组件函数可以直接访问 `reactive`/`ref` 数据，依赖变化时自动触发组件重新渲染。
- 渲染副作用在 `unmount` 时能彻底清理，避免内存泄漏或重复订阅。
- 确保现有测试通过，并补充必要的新用例覆盖组件级响应式行为。

## 迭代路线

1. **渲染副作用基础设施（已完成）**
   - 为组件实例创建 `ReactiveEffect`，封装 `component(props)` 的执行。
   - 在 `mountComponent` 中保存实例状态（最近一次子树、挂载容器、cleanup 钩子）。
   - 支持通过 `effect` 的 `scheduler` 钩子将重新渲染请求放入任务队列（初期可直接同步执行）。

2. **重新渲染流程（粗暴刷新版）（已完成）**
   - 当组件 effect 被触发时，先卸载上次渲染结果，再重新 `mountChild`。
   - 暂时接受全量重建 DOM，确保功能正确性优先。

3. **销毁与清理（已完成）**
   - 扩展 `mountComponent` 创建的实例，暴露 `unmount` 能力。
   - `render`/`createApp` 在卸载或替换节点时，主动调用组件实例的清理逻辑，停止 effect 并断开 DOM 引用。

4. **组件本地状态托管（待实现）**
   - 参考 Vue `setup()` 流程，为组件实例增加 `setupState`/`ctx`，保证函数体内创建的 `reactive`/`ref` 只初始化一次并与实例绑定。
   - 把组件执行拆分为“初始化（setup）”与“渲染”两段，effect 重跑时仅调用渲染闭包，复用已建立的状态。
   - 约定实例私有 API（对外不可见），用于在渲染期间读取 `setupState` 或注册生命周期钩子，为后续组合式能力打基础。
   - 预计代码量：核心实现（组件实例重构 + rerender 流程）约 150~200 行，实例上下文与工具 40~80 行，demo/测试 60~80 行，总体 250~350 行；可拆分为以下子任务：
     1. 重构 `mountComponent`，新增 `setupState`、渲染闭包与上下文管理。
     2. 提供实例级私有 API（如 `currentInstance`），并实现 `setup` 阶段与 effect 的衔接。
     3. 更新 demo 与 runtime-dom 测试，覆盖组件内部创建 `reactive` 的交互流程。

5. **测试补充（已完成）**
   - 在 `test/runtime-dom` 增加用例：组件仅依赖响应式数据且无手写 `effect`，多次 state 更新应正确渲染。
   - 验证卸载后响应式依赖已释放。

6. **（可选）细粒度优化**
   - 将“卸载-重建”替换为最小化的 `patch` 流程，减少 DOM 抖动。
   - 引入简单的更新调度（批量、微任务刷新）。

## 阶段验收标准

- 第 2 步完成后：组件无需额外 `effect` 即可随响应式状态更新。
- 第 3 步完成后：重复挂载/卸载无内存或副作用残留。
- 第 5 步（可选）：在性能敏感场景下减少不必要的 DOM 重建。
