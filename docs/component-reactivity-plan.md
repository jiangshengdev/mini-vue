# 组件内直接使用响应式的迭代计划

## 背景

目前函数组件在 `mountComponent` 内部只执行一次，后续依靠手写 `effect` 才能追踪响应式状态。若要让组件体内直接读取 `reactive` 数据并自动更新 UI，需要为组件引入受控的响应式渲染流程和最小化的更新机制。

## 总体目标

- 组件函数可以直接访问 `reactive`/`ref` 数据，依赖变化时自动触发组件重新渲染。
- 渲染副作用在 `unmount` 时能彻底清理，避免内存泄漏或重复订阅。
- 确保现有测试通过，并补充必要的新用例覆盖组件级响应式行为。

## 迭代路线

1. **渲染副作用基础设施**
   - 为组件实例创建 `ReactiveEffect`，封装 `component(props)` 的执行。
   - 在 `mountComponent` 中保存实例状态（最近一次子树、挂载容器、cleanup 钩子）。
   - 支持通过 `effect` 的 `scheduler` 钩子将重新渲染请求放入任务队列（初期可直接同步执行）。

2. **重新渲染流程（粗暴刷新版）**
   - 当组件 effect 被触发时，先卸载上次渲染结果，再重新 `mountChild`。
   - 暂时接受全量重建 DOM，确保功能正确性优先。

3. **销毁与清理**
   - 扩展 `mountComponent` 创建的实例，暴露 `unmount` 能力。
   - `render`/`createApp` 在卸载或替换节点时，主动调用组件实例的清理逻辑，停止 effect 并断开 DOM 引用。

4. **测试补充**
   - 在 `test/jsx` 增加用例：组件仅依赖响应式数据且无手写 `effect`，多次 state 更新应正确渲染。
   - 验证卸载后响应式依赖已释放。

5. **（可选）细粒度优化**
   - 将“卸载-重建”替换为最小化的 `patch` 流程，减少 DOM 抖动。
   - 引入简单的更新调度（批量、微任务刷新）。

## 阶段验收标准

- 第 2 步完成后：组件无需额外 `effect` 即可随响应式状态更新。
- 第 3 步完成后：重复挂载/卸载无内存或副作用残留。
- 第 5 步（可选）：在性能敏感场景下减少不必要的 DOM 重建。
